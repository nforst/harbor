import fs from "fs/promises";
import path from "path";
import { run, runCapture } from "./shell.js";
import { readConfig } from "./config.js";
import { dnsmasqDir } from "./paths.js";
import { removeFileIfExists, writeFileIfChanged, writeFileSudoIfNeeded, readFileContent } from "./file-utils.js";

function normalizeHost(host: string) {
    return host.trim().toLowerCase();
}

function safeFileName(host: string) {
    return host.replace(/[^a-z0-9._-]/gi, "_");
}

function confPathFor(host: string) {
    return path.join(dnsmasqDir(), `${safeFileName(host)}.conf`);
}

function buildDnsmasqConf(host: string, address: string) {
    return ["# generated by harbor", `address=/${host}/${address}`, `listen-address=${address}`].join("\n")
}

export async function addDnsmasqConfig(host: string) {
    host = normalizeHost(host);
    const cfg = readConfig()

    await fs.mkdir(dnsmasqDir(), { recursive: true });

    const filePath = confPathFor(host);
    const content = buildDnsmasqConf(host, cfg.dnsmasq.address);

    await writeFileIfChanged(filePath, content);
}

export async function removeDnsmasqConfig(host: string) {
    host = normalizeHost(host);
    const filePath = confPathFor(host);
    await removeFileIfExists(filePath);
}

export async function implementDnsmasqImport() {
    await fs.mkdir(dnsmasqDir(), { recursive: true });

    const dnsmasqConfPath = await resolveDnsmasqConfPath();
    const current = await readFileContent(dnsmasqConfPath);

    const importLine = `conf-dir=${dnsmasqDir()},*.conf`;

    const exists = current
        .split("\n")
        .map((l) => l.trim())
        .some((l) => l === importLine);

    if (exists) return;

    const next = [
        current.trimEnd(),
        "",
        "# harbor",
        importLine,
        "",
    ].join("\n");

    await writeFileSudoIfNeeded(dnsmasqConfPath, next);
}

/**
 * Reload dnsmasq so new domains are immediately available.
 * Uses launchctl kickstart which is allowed without password via sudoers.
 */
export async function reloadDnsmasq(): Promise<void> {
    await run('sudo', ['/bin/launchctl', 'kickstart', '-k', 'system/homebrew.mxcl.dnsmasq'], 'Restarting dnsmasq...');
}

const SUDOERS_FILE = '/etc/sudoers.d/harbor';
const SUDOERS_CONTENT = `# Harbor - allow dnsmasq restart without password
%admin ALL=(ALL) NOPASSWD: /bin/launchctl kickstart -k system/homebrew.mxcl.dnsmasq
`;

/**
 * Add sudoers rule to allow passwordless dnsmasq restart.
 */
export async function setupSudoersRule(): Promise<void> {
    const tmpPath = '/tmp/harbor-sudoers';
    await fs.writeFile(tmpPath, SUDOERS_CONTENT, { mode: 0o440 });
    
    // Validate the sudoers file before installing
    await run('sudo', ['visudo', '-c', '-f', tmpPath], 'Validating sudoers rule...');
    
    // Install the sudoers file
    await run('sudo', ['cp', tmpPath, SUDOERS_FILE], 'Installing sudoers rule for passwordless dnsmasq restart...');
    await run('sudo', ['chmod', '440', SUDOERS_FILE], undefined);
    
    await fs.unlink(tmpPath).catch(() => {});
}

/**
 * Remove the sudoers rule.
 */
export async function removeSudoersRule(): Promise<void> {
    await run('sudo', ['rm', '-f', SUDOERS_FILE], 'Removing sudoers rule...');
}

async function resolveDnsmasqConfPath(): Promise<string> {
    const prefix = await runCapture('brew', ['--prefix']);
    return path.join(prefix, 'etc', 'dnsmasq.conf');
}

function ensureTrailingSlash(p: string) {
    return p.endsWith(path.sep) ? p : p + path.sep;
}